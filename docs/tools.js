"use strict";

(() => {

    const elements = {
        setup: function() {
            this.footer = document.querySelector("main > section > footer");
            this.output = document.querySelector("textarea");
            this.inputFrom = document.querySelector("#input-unicode-subset-start");
            this.inputLength = document.querySelector("#input-unicode-subset-length");
            this.masterPassword = document.querySelector("#input-master-password");
            this.seed = document.querySelector("#input-seed");
            this.characterRepertioire = document.querySelector("#input-character-repertioire");
            this.offset = document.querySelector("#select-start");
            this.size = document.querySelector("#select-length");
            this.shift = document.querySelector("#select-shift");
            this.insertValue = document.querySelector("#input-insert-value");
            this.insertPosition = document.querySelector("#input-insert-position");
            this.password = document.querySelector("aside > div > textarea");
        }, //setup
        processMeta: function() {
            const metaElements = document.getElementsByTagName("meta");
            const mainTitleElement = document.querySelector("header");
            const copyrightElement = document.querySelector("body > footer > p:last-child b");
            const meta = {};
            for (let element of metaElements)
                meta[element.name] = element.content;
            copyrightElement.textContent = meta.copyright;
            mainTitleElement.textContent = document.title;
            mainTitleElement.title = meta.description;
        }, //processMeta
    };

    const populateSelect = (select, start, size) => {
        while (select.childElementCount) select.removeChild(select.firstElementChild);
        for (let index = start; index < size; ++index) {
            const option = document.createElement("option");
            option.value = index;
            option.textContent = `${index}`;
            select.appendChild(option);
        } //loop
        select.selectedIndex = 0;
    }; //populateSelect

    const setupSelectionUpdate = (element, updater) => {
        element.onfocus = ev => { updater(); }
        element.onclick = ev => { updater(); }
        element.onkeyup = ev => { updater(); }
        element.input = ev => { updater(); }
        element.onkeydown = ev => { updater(); }
        element.onmousemove = ev => { updater(); }
        element.onpaste = ev => { updater(); }
    }; //setupSelectionUpdate

    const setupDataChange = (elements, updater) => {
        for (let element of elements)
            if (element instanceof HTMLInputElement)
                element.oninput = updater;
            else if (element instanceof HTMLSelectElement)
                element.onchange = updater;        
    }; //setupDataChange

    window.onload = () => {
        elements.setup();
        elements.processMeta();
        populateSelect(elements.offset, 0, 64);
        populateSelect(elements.size, 1, 64);
        populateSelect(elements.shift, 0, 256);
        populateSelect(elements.insertPosition, 0, 64);        
        elements.size.selectedIndex = 23; //SA???
        const dataElements = [
            elements.masterPassword, elements.seed, elements.offset, elements.size,
            elements.characterRepertioire,
            elements.shift, elements.insertValue, elements.insertPosition
        ];
        setupDataChange(dataElements, () => {
            passwordGenerator(
                elements.masterPassword.value,
                elements.seed.value,
                elements.offset.value,
                elements.size.value,
                elements.characterRepertioire.value,
                elements.shift.value,
                { value: elements.insertValue.value, position: elements.insertPosition.value})
                    .then(autoGeneratedPassword => {
                        elements.password.textContent = autoGeneratedPassword;
                    });
        });
        const action = () => {
            const from = parseInt(elements.inputFrom.value);
            const length = parseInt(elements.inputLength.value);
            if (isNaN(from + length)) {
                elements.output.value += `\nInvalid input: "${elements.inputFrom.value}", "${elements.inputLength.value}"`;
                return;
            } //if
            let value = String.empty;
            let count = 0;
            for (let codePoint = from; codePoint < from + length; ++codePoint) {
                const character = String.fromCodePoint(codePoint);
                value += character;
                ++count;
            } //loop
            const normal = (value == value.normalize("NFC") && value == value.normalize("NFD") && value == value.normalize("NFKC") && value == value.normalize("NFKD"));
            elements.output.value += `\nCharacters: ${count}, from: 0x${from.toString(16)}, normal form: ${normal}\n${value}`;
        }; //action
        const calculateStatus = () => {
            const selected = elements.output.selectionEnd - elements.output.selectionStart;
            const line = elements.output.value.substring(0, elements.output.selectionStart);
            const split = line.split("\n");
            const y = split.length;
            const x = split[split.length - 1].length + 1;
            elements.footer.textContent = `${y} : ${x} | Selected: ${selected}`;
        }; //calculateStatus
        calculateStatus();
        setupSelectionUpdate(elements.output, calculateStatus);
        elements.inputFrom.onkeydown = ev => { if (ev.key == "Enter") action(); }
        elements.inputLength.onkeydown = ev => { if (ev.key == "Enter") action(); }
        elements.inputFrom.focus();
    } //window.onload    

})();
